"""Tutorial Classification"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/902_tutorial_1.ipynb.

# %% auto 0
__all__ = ['show_bioimage']

# %% ../nbs/902_tutorial_1.ipynb 10
@delegates(plt.Axes.imshow, keep=True, but=['shape', 'imlim'])
def show_bioimage(img, ax=None, figsize=None, title=None, max_slices=3, ctx=None, **kwargs):
    """
    Show a single BioImageMulti object, handling multi-channel CYX images appropriately.

    Parameters:
    - img: BioImageMulti object (CYX format).
    - figsize (tuple, optional): figure size in inches.
    - title (str, optional): title for the image.
    - max_slices (int, optional): maximum number of slices to show if the image has multiple channels.
    - ctx: additional context passed to the `plt.Axes.imshow` function.
    - **kwargs: additional keyword arguments passed to `plt.Axes.imshow`.

    Returns:
    - ax: matplotlib axes containing the displayed image.
    """

    # Ensure the image is a BioImageMulti object and convert to tensor
    img_tensor = img.as_tensor().cpu().numpy()

    # Set figure size if not provided
    if figsize is None:
        figsize = (5, 5) if img_tensor.shape[0] == 3 else (8, 4)  # Larger for multi-channel

    # Create axis if not provided
    ax = ifnone(ax, ctx)
    if ax is None:
        fig, ax = plt.subplots(figsize=figsize)

    # Handle RGB images (C=3)
    if img_tensor.ndim == 3 and img_tensor.shape[0] == 3:  # CYX format, where C=3 (RGB)
        img_to_show = img_tensor.transpose(1, 2, 0)  # Convert from CYX (Channels, Y, X) to YXC (Height, Width, Channels)
        ax.imshow(img_to_show/255, **kwargs)

    # Handle multi-channel images (Câ‰ 3)
    else:
        num_channels = img_tensor.shape[0]
        if num_channels <= max_slices:
            # Concatenate channels horizontally for grayscale visualization
            img_to_show = np.concatenate([img_tensor[c] for c in range(num_channels)], axis=1)
        else:
            # Show only middle slices if there are too many channels
            middle_slices = range(num_channels // 2 - max_slices // 2, num_channels // 2 + max_slices // 2)
            img_to_show = np.concatenate([img_tensor[c] for c in middle_slices], axis=1)
        ax.imshow(img_to_show, cmap='gray', **kwargs)

    # Set title for the image
    if title:
        ax.set_title(title)

    # Turn off the axis for a cleaner display
    ax.axis('off')

    return ax

